// Kyle G Gayliyev
// The University of Utah
// Homework 5, problem 4, section d)

// Spec: GF(2^2), P(X) = X^2+X+1, Z = A*B (mod P(X))
// Note (mod P(X)) is implicit, as everything in GF is (mod P(X))

// Implementation is a 3-bit Mastrovito multiplier circuit. The
// circuit is designed in this homework page 11; Problem 4, section a.


// Variables of the ring:
//
// Word-level variables: Z_s for spec, Z (implementation) A, B inputs
// Free variable: t
// Bit level variables of the circuit:
// a_0,a_1,a_2,b_0,b_1,b_2,s_0,s_1,s_2,s_3,s_4,r_0,z_0,z_1,z_2
//

// declare the ring
ring r = (2, X), (Z_s, Z, A, B, a_0,a_1,a_2, b_0,b_1,b_2, s_0,s_1,s_2,s_3,s_4,s_5,s_6,s_7,s_8,s_9,s_10,s_11,z_0,z_1,z_2,t), lp;

// Note how multi-variate rings are declared.
// The last keyword 'lp' means that terms of polynomials are ordered lexicographically

minpoly = X^3 + X +1;

// X = alpha here...

// First we will declare polynomials, and then declare an ideal

poly f_spec = Z_s + A*B; //Spec

// Implementation from gates

// Word-level to bit-level relationships
poly f1 = A + a_0 + a_1*X + a_2*X^2;
poly f2 = B + b_0 + b_1*X + b_2*X^2;
poly f3 = Z + z_0 + z_1*X + z_2*X^2;

// Polynomials representing the gates in the design
//z0 of s0:
poly f4 = s_0 + a_0*b_0; // AND gate
//z0 of s3:
poly f5 = s_1 + a_1*b_2;
poly f6 = s_2 + a_2*b_1;

// You could introduce a bug in the design by replacing the AND gate at
// s_1 to an XOR gate at s_1
// BUG:
// poly f5 = s_1 + a_1 + b_2,
// AND gate replaced by XOR

//z1 of s1:
poly f7 = s_3 + a_0*b_1;
poly f8 = s_4 + a_1*b_0;
//z1 of s3:
poly f9 = s_5 + a_1*b_2;
poly f10 = s_6 + a_2*b_1;
//z1 of s4:
poly f11 = s_7 + a_2*b_2;

//z2 of s2:
poly f12 = s_8 + a_0*b_2;//Change this to XOR from AND gate to fix 
poly f13 = s_9 + a_1*b_1;
poly f14 = s_10 + a_2*b_0;
//z2 of s4:
poly f15  = s_11 + a_2*b_2;


// Using big multi-input XOR gates
poly f16 = z_0 + s_0 + s_1 + s_2;
poly f17 = z_1 + s_3 + s_4 + s_5 + s_6 + s_7;
poly f18 = z_2 + s_8 + s_9 + s_10 + s_11;


// and now the miter polynomial

poly f_m = t*(Z_s-Z) + 1;

// Declare an ideal generated by the miter's polynomials

ideal J_0 = a_0^2-a_0, a_1^2-a_1, a_2^2-a_2, b_0^2-b_0, b_1^2-b_1, b_2^2-b_2;

ideal J_m = f_spec, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f_m;

ideal J=J_0+J_m;

// You could write out the ideal J:
printf("Ideal J is:", J);
J;


// We can compute the Groebner basis of ideal J
// G = groebner(J);

ideal G;

G = groebner(J);

printf("Groebner basis G of ideal J:");

G;


printf("If G = 1, then variety of ideal J is empty, or the miter in infeasible. \
 This is because 1=0 has no solutions!!");

printf("");
printf("");

printf("You should introduce a bug, as shown in poly f5, and recompute \
GB(J) and see for yourself the output G. If G is not equal to {1}, \
then variety is non-empty, i.e. solutions exist to ideal J.");
